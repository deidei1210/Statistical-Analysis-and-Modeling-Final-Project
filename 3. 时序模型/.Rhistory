)
} else {
company_forecasts[[company]] <- list(
Model = NA,
Forecast = NA,
Accuracy = NA
)
}
}
for (company in company_list) {
forecast_info <- company_forecasts[[company]]
cat("公司:", company, "\n")
cat("模型信息:\n")
print(forecast_info$Model)
cat("预测结果:\n")
print(forecast_info$Forecast)
cat("精度信息:\n")
print(forecast_info$Accuracy)
cat("\n")
}
library(ggplot2)
# 确保导入forecast包
library(forecast)
forecast_period <- 180
# 遍历每个公司进行预测并绘制图表
for (company in company_list) {
# 获取当前公司的模型信息
forecast_info <- company_forecasts[[company]]
# 确定历史数据的最后一个时间点作为起始点
last_observation <- max(stock_data$Date[stock_data$Company == company])
# 生成未来半年的日期，从最后一个观察点的下一天开始
# 注意：此处应考虑实际的交易日历
future_dates <- seq(from = last_observation + 1, by = "days", length.out = forecast_period)
# 使用模型进行未来半年的预测
forecast_values <- forecast(forecast_info$Model, h = forecast_period)
# 创建数据框，包括日期和预测的股票价格
historical_data <- subset(stock_data, Company == company, select = c("Date", "Close.Last"))
# 计算预测值的逆差分
last_historical_price <- head(historical_data$Close.Last, 1)
forecasted_diff <- forecast_values$mean
forecasted_price <- cumsum(c(last_historical_price, forecasted_diff[-1]))
forecast_data <- data.frame(
Date = c(historical_data$Date, future_dates[-1]),
Price = c(historical_data$Close.Last, forecasted_price[-1]),
Type = c(rep("Historical", nrow(historical_data)), rep("Forecasted", length(future_dates) - 1)),
Company = company
)
# 创建ggplot对象并绘制折线图
p <- ggplot(forecast_data, aes(x = Date, y = Price, color = Type)) +
geom_line() +
labs(title = paste("Stock Price Forecast for", company),
x = "Date",
y = "Stock Price") +
scale_color_manual(values = c("blue", "red")) +
theme_minimal()
print(p)
}
library(ggplot2)
# 确保导入forecast包
library(forecast)
forecast_period <- 180
# 遍历每个公司进行预测并绘制图表
for (company in company_list) {
# 获取当前公司的模型信息
forecast_info <- company_forecasts[[company]]
# 确定历史数据的最后一个时间点作为起始点
last_observation <- max(stock_data$Date[stock_data$Company == company])
# 生成未来半年的日期，从最后一个观察点的下一天开始
# 注意：此处应考虑实际的交易日历
future_dates <- seq(from = last_observation + 1, by = "days", length.out = forecast_period)
# 使用模型进行未来半年的预测
forecast_values <- forecast(forecast_info$Model, h = forecast_period)
# 创建数据框，包括日期和预测的股票价格
historical_data <- subset(stock_data, Company == company, select = c("Date", "Close.Last"))
# 计算预测值的逆差分
last_historical_price <- head(historical_data$Close.Last, 1)
forecasted_diff <- forecast_values$mean
forecasted_price <- cumsum(c(last_historical_price, forecasted_diff[-1]))
forecast_data <- data.frame(
Date = c(historical_data$Date, future_dates[-1]),
Price = c(historical_data$Close.Last, forecasted_price[-1]),
Type = c(rep("Historical", nrow(historical_data)), rep("Forecasted", length(future_dates) - 1)),
Company = company
)
# 创建ggplot对象并绘制折线图
p <- ggplot(forecast_data, aes(x = Date, y = Price, color = Type)) +
geom_line() +
labs(title = paste("Stock Price Forecast for", company),
x = "Date",
y = "Stock Price") +
scale_color_manual(values = c("blue", "red")) +
theme_minimal()
print(p)
}
library(forecast)
library(dplyr)
library(tseries)
company_list <- unique(diff_stock_data$Company)
company_forecasts <- list()
for (company in company_list) {
company_data <- filter(diff_stock_data, Company == company)
ts_data <- ts(company_data$DiffClose)
# 检查数据是否平稳
if (adf.test(ts_data, alternative = "stationary")$p.value > 0.05) {
ts_data <- diff(ts_data, differences = 1)
}
train_size <- floor(length(ts_data) * 0.9)
train_set <- ts_data[1:train_size]
test_set <- ts_data[(train_size + 1):length(ts_data)]
if (length(test_set) > 0) {
fit <- auto.arima(train_set, stepwise = FALSE, approximation = FALSE)
forecast_result <- forecast(fit, h = length(test_set))
company_forecasts[[company]] <- list(
Model = fit,
Forecast = forecast_result,
Accuracy = if (length(forecast_result$mean) == length(test_set)) {
accuracy(forecast_result, test_set)
} else {
NA
}
)
} else {
company_forecasts[[company]] <- list(
Model = NA,
Forecast = NA,
Accuracy = NA
)
}
}
for (company in company_list) {
forecast_info <- company_forecasts[[company]]
cat("公司:", company, "\n")
cat("模型信息:\n")
print(forecast_info$Model)
cat("预测结果:\n")
print(forecast_info$Forecast)
cat("精度信息:\n")
print(forecast_info$Accuracy)
cat("\n")
}
View(diff_stock_data)
View(diff_stock_data)
View(diff_stock_data)
View(diff_stock_data)
library(forecast)
library(dplyr)
library(tseries)
company_list <- unique(diff_stock_data$Company)
company_forecasts <- list()
for (company in company_list) {
company_data <- filter(diff_stock_data, Company == company)
# 反转时间序列，使得最新的数据在最后
ts_data <- ts(rev(company_data$DiffClose))
# 检查数据是否平稳
if (adf.test(ts_data, alternative = "stationary")$p.value > 0.05) {
ts_data <- diff(ts_data, differences = 1)
}
# 设置训练集和测试集的大小
train_size <- floor(length(ts_data) * 0.8)
train_set <- ts_data[1:train_size]
test_set <- ts_data[(train_size + 1):length(ts_data)]
if (length(test_set) > 0) {
fit <- auto.arima(train_set, stepwise = FALSE, approximation = FALSE)
forecast_result <- forecast(fit, h = length(test_set))
company_forecasts[[company]] <- list(
Model = fit,
Forecast = forecast_result,
Accuracy = if (length(forecast_result$mean) == length(test_set)) {
accuracy(forecast_result, test_set)
} else {
NA
}
)
} else {
company_forecasts[[company]] <- list(
Model = NA,
Forecast = NA,
Accuracy = NA
)
}
}
# 打印每个公司的预测结果
for (company in company_list) {
forecast_info <- company_forecasts[[company]]
cat("公司:", company, "\n")
cat("模型信息:\n")
print(forecast_info$Model)
cat("预测结果:\n")
print(forecast_info$Forecast)
cat("精度信息:\n")
print(forecast_info$Accuracy)
cat("\n")
}
library(ggplot2)
# 确保导入forecast包
library(forecast)
forecast_period <- 180
# 遍历每个公司进行预测并绘制图表
for (company in company_list) {
# 获取当前公司的模型信息
forecast_info <- company_forecasts[[company]]
# 确定历史数据的最后一个时间点作为起始点
last_observation <- max(stock_data$Date[stock_data$Company == company])
# 生成未来半年的日期，从最后一个观察点的下一天开始
# 注意：此处应考虑实际的交易日历
future_dates <- seq(from = last_observation + 1, by = "days", length.out = forecast_period)
# 使用模型进行未来半年的预测
forecast_values <- forecast(forecast_info$Model, h = forecast_period)
# 创建数据框，包括日期和预测的股票价格
historical_data <- subset(stock_data, Company == company, select = c("Date", "Close.Last"))
# 计算预测值的逆差分
last_historical_price <- head(historical_data$Close.Last, 1)
forecasted_diff <- forecast_values$mean
forecasted_price <- cumsum(c(last_historical_price, forecasted_diff[-1]))
forecast_data <- data.frame(
Date = c(historical_data$Date, future_dates[-1]),
Price = c(historical_data$Close.Last, forecasted_price[-1]),
Type = c(rep("Historical", nrow(historical_data)), rep("Forecasted", length(future_dates) - 1)),
Company = company
)
# 创建ggplot对象并绘制折线图
p <- ggplot(forecast_data, aes(x = Date, y = Price, color = Type)) +
geom_line() +
labs(title = paste("Stock Price Forecast for", company),
x = "Date",
y = "Stock Price") +
scale_color_manual(values = c("blue", "red")) +
theme_minimal()
print(p)
}
library(ggplot2)
# 确保导入forecast包
library(forecast)
forecast_period <- 180
# 遍历每个公司进行预测并绘制图表
for (company in company_list) {
# 获取当前公司的模型信息
forecast_info <- company_forecasts[[company]]
# 确定历史数据的最后一个时间点作为起始点
last_observation <- max(stock_data$Date[stock_data$Company == company])
# 生成未来半年的日期，从最后一个观察点的下一天开始
# 注意：此处应考虑实际的交易日历
future_dates <- seq(from = last_observation + 1, by = "days", length.out = forecast_period)
# 使用模型进行未来半年的预测
forecast_values <- forecast(forecast_info$Model, h = forecast_period)
# 创建数据框，包括日期和预测的股票价格
historical_data <- subset(stock_data, Company == company, select = c("Date", "Close.Last"))
# 计算预测值的逆差分
last_historical_price <- head(historical_data$Close.Last, 1)
forecasted_diff <- forecast_values$mean
forecasted_price <- cumsum(c(last_historical_price, forecasted_diff[-1]))
forecast_data <- data.frame(
Date = c(historical_data$Date, future_dates[-1]),
Price = c(historical_data$Close.Last, forecasted_price[-1]),
Type = c(rep("Historical", nrow(historical_data)), rep("Forecasted", length(future_dates) - 1)),
Company = company
)
# 创建ggplot对象并绘制折线图
p <- ggplot(forecast_data, aes(x = Date, y = Price, color = Type)) +
geom_line() +
labs(title = paste("Stock Price Forecast for", company),
x = "Date",
y = "Stock Price") +
scale_color_manual(values = c("blue", "red")) +
theme_minimal()
print(p)
}
library(forecast)
library(dplyr)
library(tseries)
company_list <- unique(diff_stock_data$Company)
company_forecasts <- list()
for (company in company_list) {
company_data <- filter(diff_stock_data, Company == company)
# 反转时间序列，使得最新的数据在最后
ts_data <- ts(rev(company_data$DiffClose))
# 检查数据是否平稳
if (adf.test(ts_data, alternative = "stationary")$p.value > 0.05) {
ts_data <- diff(ts_data, differences = 1)
}
# 设置训练集和测试集的大小
train_size <- floor(length(ts_data) * 0.9)
train_set <- ts_data[1:train_size]
test_set <- ts_data[(train_size + 1):length(ts_data)]
if (length(test_set) > 0) {
fit <- auto.arima(train_set, stepwise = FALSE, approximation = FALSE)
forecast_result <- forecast(fit, h = length(test_set))
company_forecasts[[company]] <- list(
Model = fit,
Forecast = forecast_result,
Accuracy = if (length(forecast_result$mean) == length(test_set)) {
accuracy(forecast_result, test_set)
} else {
NA
}
)
} else {
company_forecasts[[company]] <- list(
Model = NA,
Forecast = NA,
Accuracy = NA
)
}
}
# 打印每个公司的预测结果
for (company in company_list) {
forecast_info <- company_forecasts[[company]]
cat("公司:", company, "\n")
cat("模型信息:\n")
print(forecast_info$Model)
cat("预测结果:\n")
print(forecast_info$Forecast)
cat("精度信息:\n")
print(forecast_info$Accuracy)
cat("\n")
}
library(ggplot2)
# 确保导入forecast包
library(forecast)
forecast_period <- 180
# 遍历每个公司进行预测并绘制图表
for (company in company_list) {
# 获取当前公司的模型信息
forecast_info <- company_forecasts[[company]]
# 确定历史数据的最后一个时间点作为起始点
last_observation <- max(stock_data$Date[stock_data$Company == company])
# 生成未来半年的日期，从最后一个观察点的下一天开始
# 注意：此处应考虑实际的交易日历
future_dates <- seq(from = last_observation + 1, by = "days", length.out = forecast_period)
# 使用模型进行未来半年的预测
forecast_values <- forecast(forecast_info$Model, h = forecast_period)
# 创建数据框，包括日期和预测的股票价格
historical_data <- subset(stock_data, Company == company, select = c("Date", "Close.Last"))
# 计算预测值的逆差分
last_historical_price <- head(historical_data$Close.Last, 1)
forecasted_diff <- forecast_values$mean
forecasted_price <- cumsum(c(last_historical_price, forecasted_diff[-1]))
forecast_data <- data.frame(
Date = c(historical_data$Date, future_dates[-1]),
Price = c(historical_data$Close.Last, forecasted_price[-1]),
Type = c(rep("Historical", nrow(historical_data)), rep("Forecasted", length(future_dates) - 1)),
Company = company
)
# 创建ggplot对象并绘制折线图
p <- ggplot(forecast_data, aes(x = Date, y = Price, color = Type)) +
geom_line() +
labs(title = paste("Stock Price Forecast for", company),
x = "Date",
y = "Stock Price") +
scale_color_manual(values = c("blue", "red")) +
theme_minimal()
print(p)
}
library(forecast)
library(dplyr)
library(tseries)
company_list <- unique(diff_stock_data$Company)
company_forecasts <- list()
for (company in company_list) {
company_data <- filter(diff_stock_data, Company == company)
# 反转时间序列，使得最新的数据在最后
ts_data <- ts(rev(company_data$DiffClose))
# 检查数据是否平稳
if (adf.test(ts_data, alternative = "stationary")$p.value > 0.05) {
ts_data <- diff(ts_data, differences = 1)
}
# 设置训练集和测试集的大小
train_size <- floor(length(ts_data) * 0.2)
train_set <- ts_data[1:train_size]
test_set <- ts_data[(train_size + 1):length(ts_data)]
if (length(test_set) > 0) {
fit <- auto.arima(train_set, stepwise = FALSE, approximation = FALSE)
forecast_result <- forecast(fit, h = length(test_set))
company_forecasts[[company]] <- list(
Model = fit,
Forecast = forecast_result,
Accuracy = if (length(forecast_result$mean) == length(test_set)) {
accuracy(forecast_result, test_set)
} else {
NA
}
)
} else {
company_forecasts[[company]] <- list(
Model = NA,
Forecast = NA,
Accuracy = NA
)
}
}
# 打印每个公司的预测结果
for (company in company_list) {
forecast_info <- company_forecasts[[company]]
cat("公司:", company, "\n")
cat("模型信息:\n")
print(forecast_info$Model)
cat("预测结果:\n")
print(forecast_info$Forecast)
cat("精度信息:\n")
print(forecast_info$Accuracy)
cat("\n")
}
library(forecast)
library(dplyr)
library(tseries)
company_list <- unique(diff_stock_data$Company)
company_forecasts <- list()
for (company in company_list) {
company_data <- filter(diff_stock_data, Company == company)
# 反转时间序列，使得最新的数据在最后
ts_data <- ts(rev(company_data$DiffClose))
# 检查数据是否平稳
if (adf.test(ts_data, alternative = "stationary")$p.value > 0.05) {
ts_data <- diff(ts_data, differences = 1)
}
# 设置训练集和测试集的大小
train_size <- floor(length(ts_data) * 0.85)
train_set <- ts_data[1:train_size]
test_set <- ts_data[(train_size + 1):length(ts_data)]
if (length(test_set) > 0) {
fit <- auto.arima(train_set, stepwise = FALSE, approximation = FALSE)
forecast_result <- forecast(fit, h = length(test_set))
company_forecasts[[company]] <- list(
Model = fit,
Forecast = forecast_result,
Accuracy = if (length(forecast_result$mean) == length(test_set)) {
accuracy(forecast_result, test_set)
} else {
NA
}
)
} else {
company_forecasts[[company]] <- list(
Model = NA,
Forecast = NA,
Accuracy = NA
)
}
}
# 打印每个公司的预测结果
for (company in company_list) {
forecast_info <- company_forecasts[[company]]
cat("公司:", company, "\n")
cat("模型信息:\n")
print(forecast_info$Model)
cat("预测结果:\n")
print(forecast_info$Forecast)
cat("精度信息:\n")
print(forecast_info$Accuracy)
cat("\n")
}
library(ggplot2)
# 确保导入forecast包
library(forecast)
forecast_period <- 180
# 遍历每个公司进行预测并绘制图表
for (company in company_list) {
# 获取当前公司的模型信息
forecast_info <- company_forecasts[[company]]
# 确定历史数据的最后一个时间点作为起始点
last_observation <- max(stock_data$Date[stock_data$Company == company])
# 生成未来半年的日期，从最后一个观察点的下一天开始
# 注意：此处应考虑实际的交易日历
future_dates <- seq(from = last_observation + 1, by = "days", length.out = forecast_period)
# 使用模型进行未来半年的预测
forecast_values <- forecast(forecast_info$Model, h = forecast_period)
# 创建数据框，包括日期和预测的股票价格
historical_data <- subset(stock_data, Company == company, select = c("Date", "Close.Last"))
# 计算预测值的逆差分
last_historical_price <- head(historical_data$Close.Last, 1)
forecasted_diff <- forecast_values$mean
forecasted_price <- cumsum(c(last_historical_price, forecasted_diff[-1]))
forecast_data <- data.frame(
Date = c(historical_data$Date, future_dates[-1]),
Price = c(historical_data$Close.Last, forecasted_price[-1]),
Type = c(rep("Historical", nrow(historical_data)), rep("Forecasted", length(future_dates) - 1)),
Company = company
)
# 创建ggplot对象并绘制折线图
p <- ggplot(forecast_data, aes(x = Date, y = Price, color = Type)) +
geom_line() +
labs(title = paste("Stock Price Forecast for", company),
x = "Date",
y = "Stock Price") +
scale_color_manual(values = c("blue", "red")) +
theme_minimal()
print(p)
}
library(forecast)
library(dplyr)
library(tseries)
company_list <- unique(diff_stock_data$Company)
company_forecasts <- list()
window_size <- 30  # 窗口大小，可以根据需要调整
forecast_length <- 1  # 预测步长，通常为1
for (company in company_list) {
company_data <- filter(diff_stock_data, Company == company)
ts_data <- ts(rev(company_data$DiffClose))
# 确保时间序列是平稳的
if (adf.test(ts_data, alternative = "stationary")$p.value > 0.05) {
ts_data <- diff(ts_data, differences = 1)
}
total_length <- length(ts_data)
forecasts <- list()
for (start in seq(1, total_length - window_size - forecast_length)) {
train_set <- ts_data[start:(start + window_size - 1)]
fit <- auto.arima(train_set, stepwise = FALSE, approximation = FALSE)
forecast_result <- forecast(fit, h = forecast_length)
forecasts[[start]] <- forecast_result
}
company_forecasts[[company]] <- forecasts
}
