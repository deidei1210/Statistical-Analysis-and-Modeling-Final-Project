---
title: "Stock"
output: html_notebok
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
# 安装和加载必要的库
library(ggplot2)
library(dplyr)
library(tidyr)

# 读取数据
stock_data <- read.csv("stock.csv", stringsAsFactors = FALSE)

# 数据预处理：统一日期格式
stock_data$Date <- as.Date(stock_data$Date, format="%m/%d/%Y")

# 清理并转换股票价格和交易量数据：将价格变成数据
price_columns <- c("Close.Last", "Open", "High", "Low")
for (col in price_columns) {
  stock_data[[col]] <- as.numeric(gsub("\\$", "", stock_data[[col]]))
}
stock_data$Volume <- as.numeric(gsub(",", "", stock_data$Volume))

# 处理缺失值
# 这里的策略是删除任何包含缺失值的行
stock_data <- na.omit(stock_data)

# 处理异常值，保证所有数据都是非负数
stock_data <- stock_data %>% 
  filter(Close.Last > 0, Open > 0, High > 0, Low > 0, Volume > 0)
# 数据去重
stock_data <- distinct(stock_data)
# 只关心'Company'和'Date'列的重复值
stock_data <- distinct(stock_data, Company, Date, .keep_all = TRUE)


# 为每个公司绘制箱线图（以'Close.Last'为例）
ggplot(stock_data, aes(x = Company, y = Close.Last)) +
  geom_boxplot() +
  labs(title = "Boxplot of Closing Prices for Each Company", x = "Company", y = "Close/Last Price")


```
```{r}

# 为每个公司绘制股价和交易量的散点图
ggplot(stock_data, aes(x = Volume, y = Close.Last, color = Company)) +
  geom_point() +
  labs(title = "Scatter Plot of Volume vs. Close Price", x = "Volume", y = "Close/Last Price")


```
```{r}
# 可视化所有公司股价随时间的变化
ggplot(stock_data, aes(x = Date, y = Close.Last, color = Company)) +
  geom_line() +
  labs(title = "Stock Price Over Time for All Companies", x = "Date", y = "Close Price") +
  theme(legend.position = "bottom")
# 获取公司列表
companies <- unique(stock_data$Company)

library(zoo)

# 设置移动平均的窗口大小，例如30天
window_size <- 30

# 为每个公司创建单独的股价图，包括移动平均线
for (company in unique(stock_data$Company)) {
  company_data <- filter(stock_data, Company == company)

  # 计算移动平均
  company_data$MA <- rollmean(company_data$Close.Last, window_size, align = "right", fill = NA)

  # 绘制股价图和移动平均线
  p <- ggplot(company_data, aes(x = Date)) +
       geom_line(aes(y = Close.Last), color = "blue") +
       geom_line(aes(y = MA), color = "red", na.rm = TRUE) +
       labs(title = paste(company, "Stock Price with Moving Average"), x = "Date", y = "Close Price") +
       theme(legend.position = "bottom")
  print(p)
}

```
```{r}
# 为相关性分析准备数据
stock_data_wide <- stock_data %>%
  select(Date, Company, Close.Last) %>%
  spread(key = Company, value = Close.Last)

# 计算相关性
corr_matrix <- cor(stock_data_wide[, -1], use="complete.obs")

# 可视化相关性矩阵
heatmap(corr_matrix, main="Stock Price Correlation Between Companies", Colv=NA, Rowv=NA)
print(corr_matrix)

```

```{r}
# 对每个公司的数据进行季节性分解
for (company in unique(stock_data$Company)) {
  company_data <- filter(stock_data, Company == company)

  # 将价格数据转换为时间序列对象
  ts_data <- ts(company_data$Close.Last, frequency=252)  # 假设一年有252个交易日

  # STL分解
  decomposed <- stl(ts_data, s.window="periodic")

  # 提取季节性成分
  seasonality <- decomposed$time.series[, "seasonal"]

  # 将季节性数据转换为数据框
  seasonal_data <- data.frame(Date = company_data$Date, Seasonality = seasonality)
  
  # 绘制季节性图
  pic<-ggplot(seasonal_data, aes(x = Date, y = Seasonality)) +
    geom_line() +
    labs(title = paste(company, "Seasonal Variation in Stock Price"), x = "Date", y = "Seasonality") +
    theme(legend.position = "bottom")
    print(pic)
}

```

```{r}
library(dplyr)
library(ggplot2)


# 计算每个公司的日收益率
stock_data <- stock_data %>%
  group_by(Company) %>%
  arrange(Company, Date) %>%
  mutate(Return = (Close.Last / lag(Close.Last) - 1) * 100)

# 移除缺失值
stock_data <- na.omit(stock_data)

# 使用ggplot2可视化所有公司的日收益率
ggplot(stock_data, aes(x = Date, y = Return, color = Company)) +
  geom_line() +
  labs(title = "Daily Stock Returns of All Companies", 
       x = "Date", 
       y = "Daily Return (%)") +
  theme_minimal() +
  theme(legend.position = "bottom")

# 获取所有公司的列表
companies <- unique(stock_data$Company)

# 为每个公司创建一个图
plots_list <- lapply(companies, function(company) {
  company_data <- filter(stock_data, Company == company)
  ggplot(company_data, aes(x = Date, y = Return)) +
    geom_line() +
    labs(title = paste("Daily Stock Returns of", company),
         x = "Date",
         y = "Daily Return (%)") +
    theme_minimal()
})
plots_list
```
```{r}
library(dplyr)
library(tseries)
library(lubridate)

# 将日期列转换为日期对象
stock_data$Date <- ymd(stock_data$Date)

# 初始化一个空的数据框来存储差分后的时间序列
diff_stock_data <- data.frame()

# 对每个公司进行循环
company_list <- unique(stock_data$Company)
for(company in company_list) {
  # 提取当前公司的数据
  company_data <- subset(stock_data, Company == company)
  
  # 将收盘价转换为时间序列对象
  ts_data <- ts(company_data$Close.Last)
  
  # 进行差分直到时间序列平稳
  diff_ts <- ts_data
  diff_count <- 0
  repeat {
    adf_test_results <- adf.test(diff_ts, alternative = "stationary")
    if (adf_test_results$p.value < 0.05) {
      break
    } else {
      diff_ts <- diff(diff_ts)
      diff_count <- diff_count + 1
    }
    
    if (diff_count > 10) {
      break
    }
  }
  
# 将差分后的时间序列转换为普通向量
diff_ts_vector <- as.vector(diff_ts)

# 调整Date向量以匹配差分后的时间序列长度
adjusted_dates <- company_data$Date[-seq_len(diff_count)]

# 将差分后的数据添加到数据框
diff_stock_data <- rbind(diff_stock_data, data.frame(Date = adjusted_dates, Company = company, DiffClose = diff_ts_vector))

}

# 查看结果
head(diff_stock_data)

```

```{r}

# 载入必要的库
library(forecast)
library(dplyr)

# 获取所有公司的列表
company_list <- unique(diff_stock_data$Company)

# 初始化一个列表来存储每个公司的模型结果
company_forecasts <- list()

# 对每个公司进行循环
for(company in company_list) {
  # 提取当前公司的差分后数据
  company_data <- filter(diff_stock_data, Company == company)
  
  # 将差分后的收盘价转换为时间序列对象
  ts_data <- ts(company_data$DiffClose)
  
  # 计算训练集数据点的数量
  train_size <- floor(length(ts_data) * 0.8)
  
  # 创建训练集和测试集
  train_set <- ts_data[1:train_size]
  test_set <- ts_data[(train_size+1):length(ts_data)]

  if(length(test_set) > 0) {
    # 使用auto.arima函数来自动选择合适的ARIMA模型
    fit <- auto.arima(train_set)

    # 进行预测
    forecast_result <- forecast(fit, h = length(test_set))

    # 将预测结果添加到列表中
    company_forecasts[[company]] <- list(
      Model = fit,
      Forecast = forecast_result,
      Accuracy = if(length(forecast_result$mean) == length(test_set)) {
                  accuracy(forecast_result, test_set)
                } else {
                  NA
                }
    )
  } else {
    company_forecasts[[company]] <- list(
      Model = NA,
      Forecast = NA,
      Accuracy = NA
    )
  }
}

# 遍历company_forecasts列表并打印每个公司的预测结果
for (company in company_list) {
  forecast_info <- company_forecasts[[company]]
  cat("公司:", company, "\n")
  cat("模型信息:\n")
  print(forecast_info$Model)
  cat("预测结果:\n")
  print(forecast_info$Forecast)
  cat("精度信息:\n")
  print(forecast_info$Accuracy)
  cat("\n")
}


```



```{r}
# 获取所有公司的列表
company_list <- unique(diff_stock_data$Company)

# 初始化一个列表来存储每个公司的时间范围
company_time_ranges <- list()

# 对每个公司进行循环
for (company in company_list) {
  # 使用subset选择当前公司的数据
  company_data <- subset(diff_stock_data, Company == company)
  
  # 计算训练集数据点的数量
  train_size <- floor(length(company_data$DiffClose) * 0.85)
  
  # 将日期数字转换为Date对象
  dates <- as.Date(company_data$Date, origin = "1970-01-01")
  
  # 确定训练集的时间范围
  train_start_date <- min(dates)
  train_end_date <- dates[train_size]
  
  # 确定测试集的时间范围
  test_start_date <- dates[train_size + 1]
  test_end_date <- max(dates)
  
  # 格式化日期为字符串
  formatted_train_start <- format(train_start_date, "%Y-%m-%d")
  formatted_train_end <- format(train_end_date, "%Y-%m-%d")
  formatted_test_start <- format(test_start_date, "%Y-%m-%d")
  formatted_test_end <- format(test_end_date, "%Y-%m-%d")
  
  # 存储时间范围信息到列表中
  company_time_ranges[[company]] <- list(
    TrainStart = formatted_train_start,
    TrainEnd = formatted_train_end,
    TestStart = formatted_test_start,
    TestEnd = formatted_test_end
  )
}

# 打印每个公司的时间范围
for (company in company_list) {
  time_range <- company_time_ranges[[company]]
  cat("公司:", company, "\n")
  cat("训练集时间范围:", time_range$TrainStart, "到", time_range$TrainEnd, "\n")
  cat("测试集时间范围:", time_range$TestStart, "到", time_range$TestEnd, "\n\n")
}

```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
